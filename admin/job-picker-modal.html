<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Job Picker - FP Service Management</title>
<!-- MSAL will be inherited from parent page -->
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #f8fafc; }

/* Modal Styles */
.job-picker-modal { 
  position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 10000; 
  display: flex; align-items: center; justify-content: center; 
  backdrop-filter: blur(4px); opacity: 0; visibility: hidden; 
  transition: all 0.3s ease; 
}
.job-picker-modal.active { opacity: 1; visibility: visible; }

.modal-content { 
  background: #fff; border-radius: 16px; padding: 0; 
  width: 90%; max-width: 900px; max-height: 90vh; 
  box-shadow: 0 20px 25px -5px rgba(0,0,0,0.3); 
  transform: scale(0.9); transition: transform 0.3s ease; 
}
.job-picker-modal.active .modal-content { transform: scale(1); }

.modal-header { 
  background: linear-gradient(135deg, #1e3c72, #2a5298); 
  color: #fff; padding: 20px 24px; border-radius: 16px 16px 0 0; 
  display: flex; justify-content: space-between; align-items: center; 
}
.modal-title { font-size: 1.4em; font-weight: 700; }
.close-btn { 
  background: rgba(255,255,255,0.2); color: #fff; border: none; 
  padding: 8px; border-radius: 6px; cursor: pointer; font-size: 18px; 
  width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; 
}
.close-btn:hover { background: rgba(255,255,255,0.3); }

.modal-body { padding: 24px; max-height: 70vh; overflow-y: auto; }

/* Search Section */
.search-section { 
  background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 12px; 
  padding: 20px; margin-bottom: 20px; 
}
.search-header { font-weight: 600; color: #374151; margin-bottom: 12px; }
.search-row { display: grid; grid-template-columns: 1fr auto; gap: 12px; align-items: end; }
.search-input { 
  padding: 12px 16px; border: 2px solid #d1d5db; border-radius: 8px; 
  font-size: 14px; background: #fff; 
}
.search-input:focus { outline: none; border-color: #1e3c72; box-shadow: 0 0 0 3px rgba(30,60,114,0.1); }
.search-btn { 
  background: #1e3c72; color: #fff; border: none; padding: 12px 20px; 
  border-radius: 8px; cursor: pointer; font-weight: 600; 
}
.search-btn:hover { background: #1a3260; }

.filter-toggle { 
  margin-top: 12px; display: flex; align-items: center; gap: 8px; 
}
.checkbox { width: 18px; height: 18px; cursor: pointer; }

/* Filter Section - NEW */
.filters-section {
  background: #fff; border: 2px solid #e2e8f0; border-radius: 12px;
  padding: 20px; margin-bottom: 20px;
}
.filters-header {
  font-weight: 600; color: #374151; margin-bottom: 16px;
  display: flex; justify-content: space-between; align-items: center;
}
.clear-filters-btn {
  background: #ef4444; color: #fff; border: none; padding: 6px 12px;
  border-radius: 6px; cursor: pointer; font-size: 0.85em; font-weight: 600;
}
.clear-filters-btn:hover { background: #dc2626; }
.filters-grid {
  display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 12px;
}
.filter-group {
  display: flex; flex-direction: column; gap: 6px;
}
.filter-label {
  font-size: 0.85em; font-weight: 600; color: #64748b;
}
.filter-input {
  padding: 10px 12px; border: 2px solid #d1d5db; border-radius: 8px;
  font-size: 14px; background: #fff;
}
.filter-input:focus {
  outline: none; border-color: #1e3c72; box-shadow: 0 0 0 3px rgba(30,60,114,0.1);
}
.filter-input::placeholder { color: #9ca3af; }

/* Sort Section - NEW */
.sort-section {
  display: flex; align-items: center; gap: 12px; margin-top: 12px;
  padding-top: 12px; border-top: 1px solid #e2e8f0;
}
.sort-label {
  font-size: 0.85em; font-weight: 600; color: #64748b;
}
.sort-select {
  padding: 8px 12px; border: 2px solid #d1d5db; border-radius: 8px;
  font-size: 14px; background: #fff; cursor: pointer;
}

/* Jobs List */
.jobs-section { }
.section-header { 
  font-weight: 600; color: #374151; margin-bottom: 16px; 
  display: flex; justify-content: space-between; align-items: center; 
}
.job-count { 
  background: #e2e8f0; color: #64748b; padding: 4px 12px; 
  border-radius: 16px; font-size: 0.85em; 
}

.jobs-list { max-height: 350px; overflow-y: auto; }
.job-item { 
  background: #fff; border: 2px solid #e2e8f0; border-radius: 8px; 
  padding: 16px; margin-bottom: 12px; cursor: pointer; 
  transition: all 0.2s ease; display: flex; justify-content: space-between; align-items: center; 
}
.job-item:hover { border-color: #1e3c72; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
.job-item.selected { border-color: #10b981; background: #ecfdf5; }
.job-item.closed-job { 
  background: #fafafa; opacity: 0.8; border-color: #d1d5db; 
}
.job-item.closed-job:hover { 
  opacity: 1; border-color: #9ca3af; 
}

.job-info { flex: 1; }
.job-rego { font-weight: 700; font-size: 1.1em; color: #1e3c72; margin-bottom: 4px; }
.job-details { font-size: 0.9em; color: #64748b; margin-bottom: 4px; }
.job-date { font-size: 0.85em; color: #9ca3af; }
.job-badges {
  display: flex; gap: 8px; align-items: center; flex-wrap: wrap;
}
.job-badge { 
  background: #fef3c7; color: #92400e; padding: 4px 8px; 
  border-radius: 12px; font-size: 0.8em; font-weight: 600; 
}
.job-badge.ppi { background: #dbeafe; color: #1e40af; }
.job-badge.closed { background: #fee2e2; color: #991b1b; }
.job-badge.open { background: #d1fae5; color: #065f46; }

.loading-spinner { 
  display: flex; flex-direction: column; align-items: center; justify-content: center; 
  padding: 40px; color: #64748b; 
}
.spinner-row {
  display: flex; align-items: center; margin-bottom: 20px;
}
.spinner { 
  width: 32px; height: 32px; border: 3px solid #e2e8f0; 
  border-top: 3px solid #1e3c72; border-radius: 50%; 
  animation: spin 1s linear infinite; margin-right: 12px; 
}
@keyframes spin { to { transform: rotate(360deg); } }

/* Progress Bar - NEW */
.progress-container {
  width: 100%; max-width: 400px; margin-top: 16px;
}
.progress-bar {
  width: 100%; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;
}
.progress-fill {
  height: 100%; background: linear-gradient(90deg, #1e3c72, #2a5298);
  transition: width 0.3s ease; width: 0%;
}
.progress-text {
  margin-top: 8px; font-size: 0.85em; color: #64748b; text-align: center;
}
.progress-steps {
  margin-top: 12px; font-size: 0.75em; color: #9ca3af;
}
.progress-step {
  margin: 4px 0;
}
.progress-step.done {
  color: #10b981;
}
.progress-step.active {
  color: #1e3c72; font-weight: 600;
}

.empty-state { 
  text-align: center; padding: 40px; color: #64748b; 
}
.empty-icon { font-size: 48px; margin-bottom: 12px; }

.modal-footer { 
  padding: 20px 24px; background: #f8fafc; border-radius: 0 0 16px 16px; 
  display: flex; justify-content: flex-end; gap: 12px; border-top: 2px solid #e2e8f0; 
}
.btn-cancel { 
  background: #6b7280; color: #fff; border: none; padding: 12px 24px; 
  border-radius: 8px; cursor: pointer; font-weight: 600; 
}
.btn-select { 
  background: #10b981; color: #fff; border: none; padding: 12px 24px; 
  border-radius: 8px; cursor: pointer; font-weight: 600; 
}
.btn-select:disabled { background: #d1d5db; cursor: not-allowed; }

@media (max-width: 768px) {
  .modal-content { width: 95%; margin: 20px; }
  .search-row { grid-template-columns: 1fr; }
  .modal-body { padding: 20px; }
  .filters-grid { grid-template-columns: 1fr; }
}

/* Job Preview Styles */
.preview-row {
  display: grid; grid-template-columns: 120px 1fr; gap: 12px; 
  padding: 10px 0; border-bottom: 1px solid #e2e8f0;
}
.preview-row:last-child { border-bottom: none; }
.preview-label { font-weight: 600; color: #64748b; }
.preview-value { color: #1e293b; }
.preview-badge-row { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 4px; }
</style>
</head>
<body>

<!-- Job Picker Modal -->
<div class="job-picker-modal" id="jobPickerModal">
  <div class="modal-content">
    <div class="modal-header">
      <div class="modal-title">Select Job Registration</div>
      <button class="close-btn" onclick="closeJobPicker()">&times;</button>
    </div>
    
    <div class="modal-body">
      <!-- Job Preview Section (hidden by default) -->
      <div id="jobPreviewSection" style="display: none;">
        <div style="background: #f0f9ff; border: 2px solid #3b82f6; border-radius: 12px; padding: 24px; margin-bottom: 20px;">
          <div style="font-size: 1.3em; font-weight: 700; color: #1e40af; margin-bottom: 16px;">Selected Job</div>
          
          <div id="jobPreviewContent">
            <!-- Dynamic content will be inserted here -->
          </div>
          
          <div style="display: flex; gap: 12px; margin-top: 20px;">
            <button class="btn-cancel" onclick="backToJobList()" style="flex: 1;">
              ← Back to Job List
            </button>
            <button class="btn-select" onclick="confirmJobSelection()" style="flex: 1;">
              Accept & Continue →
            </button>
          </div>
        </div>
      </div>
      
      <!-- Job Selection Section (shown by default) -->
      <div id="jobSelectionSection">
      <!-- Direct Search Section -->
      <div class="search-section">
        <div class="search-header">Enter Job Registration Number</div>
        <div class="search-row">
          <input 
            type="text" 
            id="manualRegoInput" 
            class="search-input" 
            placeholder="Type job registration number..."
            onkeypress="handleManualRegoKeypress(event)"
          >
          <button class="search-btn" onclick="selectManualRego()">Select</button>
        </div>
        
        <div class="filter-toggle">
          <input type="checkbox" id="ppiFilter" class="checkbox" onchange="togglePPIFilter()">
          <label for="ppiFilter">Show only PPI (Pre Purchase Inspection) jobs</label>
        </div>
        
        <div class="filter-toggle">
          <input type="checkbox" id="showAllJobs" class="checkbox" onchange="toggleShowAllJobs()">
          <label for="showAllJobs">Show ALL jobs (including closed/invoiced jobs)</label>
        </div>
      </div>
      
      <!-- Advanced Filters Section - NEW -->
      <div class="filters-section">
        <div class="filters-header">
          <span>Filter Jobs</span>
          <button class="clear-filters-btn" onclick="clearAllFilters()">Clear All</button>
        </div>
        <div class="filters-grid">
          <div class="filter-group">
            <label class="filter-label">Registration</label>
            <input 
              type="text" 
              id="filterRego" 
              class="filter-input" 
              placeholder="Filter by rego..."
              oninput="applyJobFilters()"
            >
          </div>
          <div class="filter-group">
            <label class="filter-label">Customer Name</label>
            <input 
              type="text" 
              id="filterCustomer" 
              class="filter-input" 
              placeholder="Filter by customer..."
              oninput="applyJobFilters()"
            >
          </div>
          <div class="filter-group">
            <label class="filter-label">Service Type</label>
            <input 
              type="text" 
              id="filterService" 
              class="filter-input" 
              placeholder="Filter by service..."
              oninput="applyJobFilters()"
            >
          </div>
          <div class="filter-group">
            <label class="filter-label">Date From</label>
            <input 
              type="date" 
              id="filterDateFrom" 
              class="filter-input"
              onchange="applyJobFilters()"
            >
          </div>
          <div class="filter-group">
            <label class="filter-label">Date To</label>
            <input 
              type="date" 
              id="filterDateTo" 
              class="filter-input"
              onchange="applyJobFilters()"
            >
          </div>
        </div>
        
        <!-- Sort Options -->
        <div class="sort-section">
          <label class="sort-label">Sort by:</label>
          <select id="sortBy" class="sort-select" onchange="applyJobFilters()">
            <option value="date-desc">Date (Newest First)</option>
            <option value="date-asc">Date (Oldest First)</option>
            <option value="rego-asc">Registration (A-Z)</option>
            <option value="rego-desc">Registration (Z-A)</option>
            <option value="customer-asc">Customer (A-Z)</option>
            <option value="customer-desc">Customer (Z-A)</option>
          </select>
        </div>
      </div>
      
      <!-- Available Jobs List -->
      <div class="jobs-section">
        <div class="section-header">
          <span>Available Open Jobs</span>
          <span class="job-count" id="jobCount">0 jobs</span>
        </div>
        
        <div id="jobsContainer">
          <div class="loading-spinner">
            <div class="spinner"></div>
            Loading jobs from SharePoint...
          </div>
        </div>
      </div>
      </div>
      <!-- End Job Selection Section -->
    </div>
    
    <div class="modal-footer">
      <button class="btn-cancel" onclick="closeJobPicker()">Cancel</button>
      <button class="btn-select" id="selectBtn" onclick="confirmSelection()" disabled>
        Select Job
      </button>
    </div>
  </div>
</div>

<script>
// Job Picker Configuration
const JOB_PICKER_CONFIG = {
  SPO_HOST: 'roadandrescue.sharepoint.com',
  SPO_SITE_PATH: '/sites/rar',
  SPO_LIST_TITLE: 'Forman Pacific Consolidated Brand Data',
  PPI_JOB_TYPE: 'Pre Purchase Vehicle Inspection'
};

// State
let jobPickerState = {
  msalInstance: null,
  allJobs: [],
  filteredJobs: [],
  selectedJob: null,
  isPPIMode: false,
  showAllJobs: false,
  onJobSelected: null,
  isLoading: false,
  isInIframe: false,
  columnMapping: null,
  filters: {
    rego: '',
    customer: '',
    service: '',
    dateFrom: '',
    dateTo: ''
  },
  sortBy: 'date-desc', // Default: newest first
  loadingProgress: {
    current: 0,
    total: 4,
    steps: [],
    message: ''
  }
};

// MSAL Configuration
const MSAL_CONFIG = {
  auth: {
    clientId: 'd67be044-6aaa-4d01-ada2-da0cc50d2034',
    authority: 'https://login.microsoftonline.com/61ffc6bc-d9ce-458b-8120-d32187c3770d',
    redirectUri: window.location.origin + '/admin'
  },
  cache: { cacheLocation: 'sessionStorage', storeAuthStateInCookie: true }
};

const GRAPH_SCOPES = ['https://graph.microsoft.com/Sites.Read.All'];

// Detect if running in iframe
function detectIframe() {
  jobPickerState.isInIframe = window.self !== window.top;
}

// Initialize - request data from parent instead of handling auth directly
async function initJobPickerAuth() {
  try {
    // Request jobs data from parent page
    if (window.parent && window.parent !== window) {
      console.log('Requesting jobs data from parent...');
      window.parent.postMessage({
        type: 'REQUEST_JOBS_DATA'
      }, '*');
      return true;
    }
    
    // If not in iframe, try local auth
    if (window.msal && window.msal.PublicClientApplication) {
      jobPickerState.msalInstance = new msal.PublicClientApplication(MSAL_CONFIG);
      await jobPickerState.msalInstance.initialize();

      const accounts = jobPickerState.msalInstance.getAllAccounts();
      if (!accounts.length) throw new Error('No authenticated account');

      return true;
    }
    
    throw new Error('Not in iframe and MSAL not available');
  } catch (error) {
    console.error('Job picker init failed:', error);
    return false;
  }
}

// Get Graph API token
async function getJobPickerToken() {
  const account = jobPickerState.msalInstance.getActiveAccount() || 
                 jobPickerState.msalInstance.getAllAccounts()[0];
  if (!account) throw new Error('No signed-in account');

  const request = { scopes: GRAPH_SCOPES, account };
  try {
    const { accessToken } = await jobPickerState.msalInstance.acquireTokenSilent(request);
    return accessToken;
  } catch (err) {
    console.warn('Silent token failed; attempting interactive', err);
    const resp = await jobPickerState.msalInstance.acquireTokenPopup({ scopes: GRAPH_SCOPES });
    return resp?.accessToken || '';
  }
}

// Update loading progress
function updateLoadingProgress(step, message) {
  const progress = jobPickerState.loadingProgress;
  
  if (step === 'start') {
    progress.current = 0;
    progress.steps = [
      { name: 'Authenticating...', done: false, active: true },
      { name: 'Connecting to SharePoint...', done: false, active: false },
      { name: 'Loading column configuration...', done: false, active: false },
      { name: 'Fetching job data...', done: false, active: false }
    ];
    progress.message = message || 'Starting...';
  } else if (typeof step === 'number') {
    progress.current = step;
    progress.steps.forEach((s, i) => {
      s.done = i < step;
      s.active = i === step;
    });
    progress.message = message || progress.steps[step]?.name || '';
  }
  
  updateJobsDisplay();
}

// Get column mapping from SharePoint (with cache)
async function getColumnMapping() {
  // Check cache first
  const cacheKey = 'jobPicker_columnMapping';
  const cacheExpiry = 24 * 60 * 60 * 1000; // 24 hours
  
  try {
    const cached = localStorage.getItem(cacheKey);
    const cacheTime = localStorage.getItem(cacheKey + '_time');
    
    if (cached && cacheTime) {
      const age = Date.now() - parseInt(cacheTime);
      if (age < cacheExpiry) {
        console.log('Using cached column mapping');
        jobPickerState.columnMapping = JSON.parse(cached);
        return jobPickerState.columnMapping;
      }
    }
  } catch (e) {
    console.warn('Cache read failed:', e);
  }
  
  if (jobPickerState.columnMapping) return jobPickerState.columnMapping;
  
  try {
    const token = await getJobPickerToken();
    
    // Step 1: Get site
    const siteUrl = `https://graph.microsoft.com/v1.0/sites/${JOB_PICKER_CONFIG.SPO_HOST}:${JOB_PICKER_CONFIG.SPO_SITE_PATH}`;
    const siteResponse = await fetch(siteUrl, { headers: { Authorization: `Bearer ${token}` }});
    const site = await siteResponse.json();
    
    // Step 2: Get list (need this before columns)
    const listNameOData = JOB_PICKER_CONFIG.SPO_LIST_TITLE.replace(/'/g, "''");
    const listsUrl = `https://graph.microsoft.com/v1.0/sites/${site.id}/lists?$filter=displayName eq '${listNameOData}'`;
    const listsResponse = await fetch(listsUrl, { headers: { Authorization: `Bearer ${token}` }});
    const listsData = await listsResponse.json();
    const listId = listsData.value[0].id;
    
    // Step 3: Get columns
    const columnsUrl = `https://graph.microsoft.com/v1.0/sites/${site.id}/lists/${listId}/columns`;
    const columnsResponse = await fetch(columnsUrl, { headers: { Authorization: `Bearer ${token}` }});
    const columnsData = await columnsResponse.json();
    
    // Create mapping
    const columnMapping = {};
    columnsData.value?.forEach(col => {
      if (col.name && col.displayName) {
        columnMapping[col.name] = col.displayName;
      }
    });
    
    jobPickerState.columnMapping = columnMapping;
    
    // Save to cache
    try {
      localStorage.setItem(cacheKey, JSON.stringify(columnMapping));
      localStorage.setItem(cacheKey + '_time', Date.now().toString());
      console.log('Column mapping cached');
    } catch (e) {
      console.warn('Cache write failed:', e);
    }
    
    return columnMapping;
    
  } catch (error) {
    console.error('Column mapping failed:', error);
    return null;
  }
}

// Parse date from job - uses StartTime only
function parseJobDate(job) {
  const dateValue = job.StartTime;
  if (dateValue) {
    const parsed = new Date(dateValue);
    if (!isNaN(parsed.getTime()) && parsed.getTime() !== 0) {
      return parsed;
    }
  }
  return new Date(0);
}

// Format date for display in NZ timezone
function formatJobDate(date) {
  if (!date || date.getTime() === 0) return 'No date';
  
  // Convert both dates to NZ timezone for comparison
  const now = new Date();
  const nzFormatter = new Intl.DateTimeFormat('en-NZ', { timeZone: 'Pacific/Auckland' });
  
  // Get NZ date components
  const nzDateStr = date.toLocaleString('en-NZ', { timeZone: 'Pacific/Auckland' });
  const nzNowStr = now.toLocaleString('en-NZ', { timeZone: 'Pacific/Auckland' });
  
  const nzDate = new Date(nzDateStr);
  const nzNow = new Date(nzNowStr);
  
  const diffDays = Math.floor((nzNow - nzDate) / (1000 * 60 * 60 * 24));
  
  const timeStr = date.toLocaleTimeString('en-NZ', { 
    hour: '2-digit', 
    minute: '2-digit',
    hour12: true,
    timeZone: 'Pacific/Auckland'
  });
  
  if (diffDays === 0) {
    return `Today at ${timeStr}`;
  } else if (diffDays === 1) {
    return `Yesterday at ${timeStr}`;
  } else if (diffDays < 7) {
    const dayName = date.toLocaleDateString('en-NZ', { 
      weekday: 'long',
      timeZone: 'Pacific/Auckland'
    });
    return `${dayName} at ${timeStr}`;
  } else if (nzDate.getFullYear() === nzNow.getFullYear()) {
    const dateStr = date.toLocaleDateString('en-NZ', { 
      month: 'short', 
      day: 'numeric',
      timeZone: 'Pacific/Auckland'
    });
    return `${dateStr} at ${timeStr}`;
  } else {
    const dateStr = date.toLocaleDateString('en-NZ', { 
      year: 'numeric',
      month: 'short', 
      day: 'numeric',
      timeZone: 'Pacific/Auckland'
    });
    return `${dateStr} at ${timeStr}`;
  }
}

// Apply column mapping to job data
function applyColumnMapping(rawJobs) {
  if (!jobPickerState.columnMapping) {
    return rawJobs;
  }
  
  return rawJobs.map(rawJob => {
    const mappedJob = {};
    
    Object.keys(rawJob).forEach(internalName => {
      const displayName = jobPickerState.columnMapping[internalName] || internalName;
      mappedJob[displayName] = rawJob[internalName];
      // Also keep original field names for backward compatibility
      mappedJob[internalName] = rawJob[internalName];
    });
    
    return mappedJob;
  });
}

// Fetch jobs from SharePoint (OPTIMIZED with parallel calls)
async function fetchJobsFromSharePoint() {
  jobPickerState.isLoading = true;
  updateLoadingProgress('start', 'Initializing...');

  try {
    // Step 0: Get token
    updateLoadingProgress(0, 'Authenticating...');
    const token = await getJobPickerToken();
    
    // Step 1: Get site
    updateLoadingProgress(1, 'Connecting to SharePoint...');
    const siteUrl = `https://graph.microsoft.com/v1.0/sites/${JOB_PICKER_CONFIG.SPO_HOST}:${JOB_PICKER_CONFIG.SPO_SITE_PATH}`;
    const siteResponse = await fetch(siteUrl, { headers: { Authorization: `Bearer ${token}` }});
    const site = await siteResponse.json();

    // Step 2: Get list
    const listNameOData = JOB_PICKER_CONFIG.SPO_LIST_TITLE.replace(/'/g, "''");
    const listsUrl = `https://graph.microsoft.com/v1.0/sites/${site.id}/lists?$filter=displayName eq '${listNameOData}'`;
    const listsResponse = await fetch(listsUrl, { headers: { Authorization: `Bearer ${token}` }});
    const listsData = await listsResponse.json();
    const listId = listsData.value[0].id;

    // Step 3 & 4: PARALLEL - Get column mapping AND items at the same time
    updateLoadingProgress(2, 'Loading configuration and data...');
    
    const [columnMapping, itemsData] = await Promise.all([
      // Get column mapping (from cache or API)
      getColumnMapping().catch(err => {
        console.warn('Column mapping failed, continuing without it:', err);
        return null;
      }),
      
      // Get ALL items with pagination support
      (async () => {
        updateLoadingProgress(3, 'Fetching job data...');
        let allItems = [];
        let nextLink = `https://graph.microsoft.com/v1.0/sites/${site.id}/lists/${listId}/items?$expand=fields&$top=999`;
        
        // Fetch all pages
        while (nextLink) {
          const response = await fetch(nextLink, { headers: { Authorization: `Bearer ${token}` }});
          const data = await response.json();
          
          if (data.value) {
            allItems = allItems.concat(data.value);
          }
          
          // Check for next page
          nextLink = data['@odata.nextLink'] || null;
          
          if (nextLink) {
            console.log(`Fetched ${allItems.length} items, loading more...`);
          }
        }
        
        console.log(`Total items fetched: ${allItems.length}`);
        return { value: allItems };
      })()
    ]);

    // Apply column mapping
    const rawJobs = (itemsData.value || []).map(item => item.fields);
    const mappedJobs = applyColumnMapping(rawJobs);
    
    // Process ALL jobs and mark their open/closed status
    const allJobsWithStatus = mappedJobs.filter(job => {
      const rego = job.Rego || job.Registration || job['Registration Number'];
      // Must have a rego to be valid
      return rego && String(rego).trim();
    }).map(job => {
      const completionTime = job.CompletionTime;
      const invoiceIdentifier = job.InvoiceIdentifier;
      
      // A job is OPEN if CompletionTime is empty/null
      // CompletionTime indicates when the job was actually completed
      const completionStr = String(completionTime || '').trim();
      const isOpen = !completionTime || completionStr === '';
      
      const invoiceStr = String(invoiceIdentifier || '').trim();
      
      return {
        ...job,
        parsedDate: parseJobDate(job),
        isOpen: isOpen,
        invoiceId: invoiceStr || 'N/A',
        completionTime: completionStr || 'Not completed'
      };
    });
    
    console.log(`Total jobs loaded: ${allJobsWithStatus.length}`);
    console.log(`Open jobs: ${allJobsWithStatus.filter(j => j.isOpen).length}`);
    console.log(`Closed jobs: ${allJobsWithStatus.filter(j => !j.isOpen).length}`);
    
    jobPickerState.allJobs = allJobsWithStatus;
    applyJobFilters();
    
  } catch (error) {
    console.error('Failed to load jobs:', error);
    showJobPickerError('Failed to load jobs from SharePoint: ' + error.message);
  } finally {
    jobPickerState.isLoading = false;
    updateJobsDisplay();
  }
}

// Sort jobs
function sortJobs(jobs) {
  const [sortField, sortOrder] = jobPickerState.sortBy.split('-');
  
  return [...jobs].sort((a, b) => {
    let aVal, bVal;
    
    switch (sortField) {
      case 'date':
        aVal = a.parsedDate.getTime();
        bVal = b.parsedDate.getTime();
        break;
      case 'rego':
        aVal = String(a.Rego || '').toLowerCase();
        bVal = String(b.Rego || '').toLowerCase();
        break;
      case 'customer':
        aVal = String(a.CustomerName || '').toLowerCase();
        bVal = String(b.CustomerName || '').toLowerCase();
        break;
      default:
        return 0;
    }
    
    if (sortOrder === 'asc') {
      return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
    } else {
      return aVal < bVal ? 1 : aVal > bVal ? -1 : 0;
    }
  });
}

// Apply filters to jobs
function applyJobFilters() {
  // Get filter values from inputs
  jobPickerState.filters.rego = document.getElementById('filterRego')?.value.toLowerCase() || '';
  jobPickerState.filters.customer = document.getElementById('filterCustomer')?.value.toLowerCase() || '';
  jobPickerState.filters.service = document.getElementById('filterService')?.value.toLowerCase() || '';
  jobPickerState.filters.dateFrom = document.getElementById('filterDateFrom')?.value || '';
  jobPickerState.filters.dateTo = document.getElementById('filterDateTo')?.value || '';
  jobPickerState.sortBy = document.getElementById('sortBy')?.value || 'date-desc';
  
  let filtered = [...jobPickerState.allJobs];
  
  // Show All Jobs toggle - if OFF, only show open jobs
  if (!jobPickerState.showAllJobs) {
    filtered = filtered.filter(job => job.isOpen);
  }
  
  // PPI filter
  if (jobPickerState.isPPIMode) {
    filtered = filtered.filter(job => {
      const serviceType = String(job.ServiceType || '');
      return serviceType.toLowerCase().includes('pre purchase') || 
             serviceType.toLowerCase().includes('ppi') ||
             serviceType.toLowerCase().includes('inspection');
    });
  }
  
  // Text filters
  if (jobPickerState.filters.rego) {
    filtered = filtered.filter(job => {
      const rego = String(job.Rego || '').toLowerCase();
      return rego.includes(jobPickerState.filters.rego);
    });
  }
  
  if (jobPickerState.filters.customer) {
    filtered = filtered.filter(job => {
      const customer = String(job.CustomerName || '').toLowerCase();
      return customer.includes(jobPickerState.filters.customer);
    });
  }
  
  if (jobPickerState.filters.service) {
    filtered = filtered.filter(job => {
      const service = String(job.ServiceType || '').toLowerCase();
      return service.includes(jobPickerState.filters.service);
    });
  }
  
  // Date filters
  if (jobPickerState.filters.dateFrom) {
    const fromDate = new Date(jobPickerState.filters.dateFrom);
    fromDate.setHours(0, 0, 0, 0);
    filtered = filtered.filter(job => job.parsedDate >= fromDate);
  }
  
  if (jobPickerState.filters.dateTo) {
    const toDate = new Date(jobPickerState.filters.dateTo);
    toDate.setHours(23, 59, 59, 999);
    filtered = filtered.filter(job => job.parsedDate <= toDate);
  }
  
  // Sort
  filtered = sortJobs(filtered);
  
  jobPickerState.filteredJobs = filtered;
  updateJobsDisplay();
}

// Clear all filters
function clearAllFilters() {
  document.getElementById('filterRego').value = '';
  document.getElementById('filterCustomer').value = '';
  document.getElementById('filterService').value = '';
  document.getElementById('filterDateFrom').value = '';
  document.getElementById('filterDateTo').value = '';
  document.getElementById('sortBy').value = 'date-desc';
  
  applyJobFilters();
}

// Toggle PPI filter
function togglePPIFilter() {
  jobPickerState.isPPIMode = document.getElementById('ppiFilter').checked;
  applyJobFilters();
}

// Toggle Show All Jobs
function toggleShowAllJobs() {
  jobPickerState.showAllJobs = document.getElementById('showAllJobs').checked;
  applyJobFilters();
}

// Update jobs display
function updateJobsDisplay() {
  const container = document.getElementById('jobsContainer');
  const countEl = document.getElementById('jobCount');
  
  if (jobPickerState.isLoading) {
    const progress = jobPickerState.loadingProgress;
    const percentage = Math.round((progress.current / progress.total) * 100);
    
    container.innerHTML = `
      <div class="loading-spinner">
        <div class="spinner-row">
          <div class="spinner"></div>
          <span>Loading jobs from SharePoint...</span>
        </div>
        <div class="progress-container">
          <div class="progress-bar">
            <div class="progress-fill" style="width: ${percentage}%"></div>
          </div>
          <div class="progress-text">${progress.message}</div>
          <div class="progress-steps">
            ${progress.steps.map(step => `
              <div class="progress-step ${step.done ? 'done' : ''} ${step.active ? 'active' : ''}">
                ${step.done ? '✓' : step.active ? '⟳' : '○'} ${step.name}
              </div>
            `).join('')}
          </div>
        </div>
      </div>
    `;
    countEl.textContent = 'Loading...';
    return;
  }
  
  const jobs = jobPickerState.filteredJobs;
  countEl.textContent = `${jobs.length} job${jobs.length !== 1 ? 's' : ''}`;
  
  if (!jobs.length) {
    const filterText = jobPickerState.isPPIMode ? 'PPI ' : '';
    const modeText = jobPickerState.showAllJobs ? 'all ' : 'open ';
    const hasFilters = jobPickerState.filters.rego || jobPickerState.filters.customer || 
                      jobPickerState.filters.service || jobPickerState.filters.dateFrom || 
                      jobPickerState.filters.dateTo;
    
    container.innerHTML = `
      <div class="empty-state">
        <div class="empty-icon">📋</div>
        <div>No ${filterText}${modeText}jobs ${hasFilters ? 'match your filters' : 'available'}</div>
        <div style="font-size: 0.9em; margin-top: 8px;">
          ${hasFilters ? 'Try adjusting your filters' : 
            jobPickerState.isPPIMode ? 'Try unchecking the PPI filter' : 
            jobPickerState.showAllJobs ? 'No jobs found in the system' : 'All jobs may be closed or completed'}
        </div>
      </div>
    `;
    return;
  }
  
  container.innerHTML = `
    <div class="jobs-list">
      ${jobs.map((job, index) => {
        const rego = job.Rego || 'Unknown';
        const customer = job.CustomerName || 'Unknown Customer';
        const service = job.ServiceType || 'Service';
        const isPPI = String(service).toLowerCase().includes('pre purchase') || 
                     String(service).toLowerCase().includes('ppi');
        const dateDisplay = formatJobDate(job.parsedDate);
        const isOpen = job.isOpen;
        const completionTime = job.completionTime || 'N/A';
        
        return `
          <div class="job-item ${!isOpen ? 'closed-job' : ''}" onclick="selectJob(${index})" data-index="${index}">
            <div class="job-info">
              <div class="job-rego">${index + 1}. ${rego}</div>
              <div class="job-details">${customer} - ${service}</div>
              <div class="job-date">📅 ${dateDisplay}</div>
              ${!isOpen ? `<div class="job-date" style="color: #ef4444;">✓ Completed: ${completionTime}</div>` : ''}
            </div>
            <div class="job-badges">
              ${isOpen ? '<div class="job-badge open">OPEN</div>' : '<div class="job-badge closed">CLOSED</div>'}
              ${isPPI ? '<div class="job-badge ppi">PPI</div>' : '<div class="job-badge">Service</div>'}
            </div>
          </div>
        `;
      }).join('')}
    </div>
  `;
}

// Select job from list
function selectJob(index) {
  document.querySelectorAll('.job-item').forEach(item => {
    item.classList.remove('selected');
  });
  
  const jobItem = document.querySelector(`[data-index="${index}"]`);
  if (jobItem) {
    jobItem.classList.add('selected');
    jobPickerState.selectedJob = jobPickerState.filteredJobs[index];
    document.getElementById('selectBtn').disabled = false;
  }
}

// Handle manual rego entry
function handleManualRegoKeypress(event) {
  if (event.key === 'Enter') {
    selectManualRego();
  }
}

function selectManualRego() {
  const input = document.getElementById('manualRegoInput');
  const rego = input.value.trim();
  
  if (!rego) {
    alert('Please enter a job registration number');
    return;
  }
  
  const foundInList = jobPickerState.filteredJobs.find(job => {
    const jobRego = job.Rego || '';
    return String(jobRego).toLowerCase() === rego.toLowerCase();
  });
  
  if (foundInList) {
    // Warn if selecting a closed job
    if (!foundInList.isOpen && !confirm(`Warning: ${rego} is a CLOSED job (Completed: ${foundInList.completionTime}). Are you sure you want to select it?`)) {
      return;
    }
    jobPickerState.selectedJob = foundInList;
  } else if (jobPickerState.isPPIMode) {
    alert('That registration number is not in the available PPI jobs list.');
    return;
  } else {
    jobPickerState.selectedJob = { Rego: rego, isManualEntry: true, isOpen: true };
  }
  
  confirmSelection();
}

// Confirm job selection - now shows preview first
function confirmSelection() {
  if (!jobPickerState.selectedJob) {
    alert('Please select a job first');
    return;
  }
  
  // Show preview screen
  showJobPreview(jobPickerState.selectedJob);
}

// Show job preview screen
function showJobPreview(job) {
  // Build comprehensive preview showing all available data
  const sections = [];
  
  // Header with rego
  const rego = job.Rego || 'Unknown';
  const isPPI = String(job.ServiceType || '').toLowerCase().includes('pre purchase') || 
               String(job.ServiceType || '').toLowerCase().includes('ppi');
  const isOpen = job.isOpen;
  
  let previewHTML = `
    <div style="font-size: 1.5em; font-weight: 700; color: #1e3c72; margin-bottom: 16px;">
      Job: ${rego}
    </div>
    
    <div class="preview-badge-row" style="margin-bottom: 20px;">
      ${isOpen ? '<div class="job-badge open">OPEN</div>' : '<div class="job-badge closed">CLOSED</div>'}
      ${isPPI ? '<div class="job-badge ppi">PPI</div>' : '<div class="job-badge">Service</div>'}
    </div>
  `;
  
  // CORE INFO
  const coreFields = [
    { label: 'ID', value: job.Id },
    { label: 'Start Time', value: job.StartTime ? new Date(job.StartTime).toLocaleString('en-NZ', { 
      year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit', hour12: true,
      timeZone: 'Pacific/Auckland'
    }) : null },
    { label: 'Completion Time', value: job.CompletionTime ? new Date(job.CompletionTime).toLocaleString('en-NZ', { 
      year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit', hour12: true,
      timeZone: 'Pacific/Auckland'
    }) : null },
  ];
  
  const coreSection = buildSection('Job Information', coreFields);
  if (coreSection) sections.push(coreSection);
  
  // CUSTOMER INFO
  const customerFields = [
    { label: 'Customer Name', value: job.CustomerName },
    { label: 'First Name', value: job.FirstName },
    { label: 'Last Name', value: job.LastName },
    { label: 'Email', value: job.Email },
    { label: 'Phone', value: job.CallerPhone },
    { label: 'Customer Phone', value: job.CustomerPhone },
    { label: 'Country Code', value: job.CountryCode },
    { label: 'Address', value: job.CustomerAddress },
    { label: 'Location', value: job.CustomerLocation },
  ];
  
  const customerSection = buildSection('Customer Information', customerFields);
  if (customerSection) sections.push(customerSection);
  
  // VEHICLE INFO
  const vehicleFields = [
    { label: 'Registration', value: job.Rego },
    { label: 'Make', value: job.Make },
    { label: 'Model', value: job.Model },
    { label: 'Year', value: job.VehicleYear },
    { label: 'Type', value: job.VehicleType },
    { label: 'Description', value: job.VehicleDescription },
    { label: 'Battery Voltage', value: job.BatteryVoltage },
    { label: 'Tyre Size', value: job.TyreSize },
  ];
  
  const vehicleSection = buildSection('Vehicle Information', vehicleFields);
  if (vehicleSection) sections.push(vehicleSection);
  
  // SERVICE INFO
  const serviceFields = [
    { label: 'Service Type', value: job.ServiceType },
    { label: 'Service Required', value: job.ServiceRequired },
    { label: 'Service Code', value: job.ServiceCode },
    { label: 'Service Title', value: job.ServiceTitle },
    { label: 'Service Category', value: job.ServiceCategory },
    { label: 'Fault', value: job.Fault },
    { label: 'Details', value: job.Details },
    { label: 'Special Requirements', value: job.SpecialRequirements },
    { label: 'Notes', value: job.Notes },
    { label: 'Job Notes', value: job.JobNotes },
    { label: 'Description', value: job.Description },
  ];
  
  const serviceSection = buildSection('Service Details', serviceFields);
  if (serviceSection) sections.push(serviceSection);
  
  // LOCATION INFO
  const locationFields = [
    { label: 'From Location', value: job.FromLocation },
    { label: 'To Location', value: job.ToLocation },
  ];
  
  const locationSection = buildSection('Location', locationFields);
  if (locationSection) sections.push(locationSection);
  
  // PRICING INFO
  const pricingFields = [
    { label: 'Price', value: job.Price ? `$${job.Price}` : null },
    { label: 'Base Price', value: job.BasePrice ? `$${job.BasePrice}` : null },
    { label: 'Vehicle Addon', value: job.VehicleAddon ? `$${job.VehicleAddon}` : null },
    { label: 'Location Surcharge', value: job.LocationSurcharge ? `$${job.LocationSurcharge}` : null },
    { label: 'Total Price', value: job.TotalPrice ? `$${job.TotalPrice}` : null },
    { label: 'Final Price', value: job.FinalPrice ? `$${job.FinalPrice}` : null },
    { label: 'Calculated Price', value: job.CalculatedPrice ? `$${job.CalculatedPrice}` : null },
    { label: 'Amount', value: job.Amount ? `$${job.Amount}` : null },
    { label: 'Paid Amount', value: job.PaidAmount ? `$${job.PaidAmount}` : null },
    { label: 'Outstanding Amount', value: job.OutstandingAmount ? `$${job.OutstandingAmount}` : null },
  ];
  
  const pricingSection = buildSection('Pricing', pricingFields);
  if (pricingSection) sections.push(pricingSection);
  
  // PAYMENT INFO
  const paymentFields = [
    { label: 'Payment Method', value: job.PaymentMethod },
    { label: 'Currency', value: job.Currency },
    { label: 'Payment Status', value: job.PaymentStatus },
    { label: 'Stripe Payment ID', value: job.StripePaymentID },
    { label: 'Paid', value: job.Paid },
  ];
  
  const paymentSection = buildSection('Payment', paymentFields);
  if (paymentSection) sections.push(paymentSection);
  
  // SUPPLIER INFO
  const supplierFields = [
    { label: 'Supplier Name', value: job.SupplierName },
    { label: 'Supplier Cost', value: job.SupplierCost ? `$${job.SupplierCost}` : null },
    { label: 'Supplier Email', value: job.SupplierEmail },
    { label: 'Supplier Phone', value: job.SupplierPhone },
    { label: 'Bank Account', value: job.BankAccount },
    { label: 'Supplier Status', value: job.SupplierStatus },
    { label: 'Supplier Rating', value: job.SupplierRating },
    { label: 'Supplier Update', value: job.SupplierUpdate },
    { label: 'ETA', value: job.ETA },
  ];
  
  const supplierSection = buildSection('Supplier', supplierFields);
  if (supplierSection) sections.push(supplierSection);
  
  // SCHEDULING INFO
  const schedulingFields = [
    { label: 'Requested Date', value: job.RequestedDate ? new Date(job.RequestedDate).toLocaleString('en-NZ', { 
      year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit', hour12: true,
      timeZone: 'Pacific/Auckland'
    }) : null },
    { label: 'Requested Time', value: job.RequestedTime },
    { label: 'Scheduled Date', value: job.ScheduledDate },
    { label: 'Scheduled Time', value: job.ScheduledTime },
    { label: 'Time Window', value: job.TimeWindow },
    { label: 'Estimated Duration', value: job.EstimatedDuration },
    { label: 'Dispatch Time', value: job.DispatchTime ? new Date(job.DispatchTime).toLocaleString('en-NZ', { 
      year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit', hour12: true,
      timeZone: 'Pacific/Auckland'
    }) : null },
    { label: 'Arrival Time', value: job.ArrivalTime ? new Date(job.ArrivalTime).toLocaleString('en-NZ', { 
      year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit', hour12: true,
      timeZone: 'Pacific/Auckland'
    }) : null },
  ];
  
  const schedulingSection = buildSection('Scheduling', schedulingFields);
  if (schedulingSection) sections.push(schedulingSection);
  
  // STATUS INFO
  const statusFields = [
    { label: 'Job Status', value: job.JobStatus },
    { label: 'Status', value: job.Status },
    { label: 'Booking Status', value: job.BookingStatus },
    { label: 'Forman Status', value: job.FormanStatus },
    { label: 'Status Description', value: job.StatusDescription },
  ];
  
  const statusSection = buildSection('Status', statusFields);
  if (statusSection) sections.push(statusSection);
  
  // INVOICE INFO
  const invoiceFields = [
    { label: 'Invoice Number', value: job.InvoiceNumber || job.InvNbr },
    { label: 'Invoice Date', value: job.InvoiceDate ? new Date(job.InvoiceDate).toLocaleString('en-NZ', { 
      year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit', hour12: true,
      timeZone: 'Pacific/Auckland'
    }) : null },
    { label: 'Net Income', value: job.NetIncome ? `$${job.NetIncome}` : null },
    { label: 'Bad Debt', value: job.BadDebt ? `$${job.BadDebt}` : null },
    { label: 'Close And Post', value: job.CloseAndPost },
    { label: 'Batch File Created', value: job.BatchFileCreated },
  ];
  
  const invoiceSection = buildSection('Invoice/Accounting', invoiceFields);
  if (invoiceSection) sections.push(invoiceSection);
  
  // REFERENCE INFO
  const referenceFields = [
    { label: 'Job Reference', value: job.JobReference },
    { label: 'Primary Reference', value: job.PrimaryReference },
    { label: 'Session ID', value: job.SessionID },
    { label: 'Forman Job ID', value: job.FormanJobID },
    { label: 'Quote Reference', value: job.QuoteReference },
    { label: 'WINZ Quote Reference', value: job.WinzQuoteReference },
    { label: 'WINZ Approval Number', value: job.WINZApprovalNumber },
    { label: 'External References', value: job.ExternalReferences },
  ];
  
  const referenceSection = buildSection('References', referenceFields);
  if (referenceSection) sections.push(referenceSection);
  
  // URGENCY INFO
  const urgencyFields = [
    { label: 'Emergency Type', value: job.EmergencyType },
    { label: 'Emergency Label', value: job.EmergencyLabel },
    { label: 'Emergency Description', value: job.EmergencyDescription },
    { label: 'Urgency Level', value: job.UrgencyLevel },
    { label: 'Urgency Title', value: job.UrgencyTitle },
    { label: 'Priority Level', value: job.PriorityLevel },
  ];
  
  const urgencySection = buildSection('Urgency/Priority', urgencyFields);
  if (urgencySection) sections.push(urgencySection);
  
  // SELLER INFO
  const sellerFields = [
    { label: 'Seller Name', value: job.SellerName },
    { label: 'Seller Phone', value: job.SellerPhone },
  ];
  
  const sellerSection = buildSection('Seller', sellerFields);
  if (sellerSection) sections.push(sellerSection);
  
  // SYSTEM INFO
  const systemFields = [
    { label: 'Brand', value: job.Brand },
    { label: 'Created Date', value: job.CreatedDate ? new Date(job.CreatedDate).toLocaleString('en-NZ', { 
      year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit', hour12: true,
      timeZone: 'Pacific/Auckland'
    }) : null },
    { label: 'Last Updated', value: job.LastUpdated ? new Date(job.LastUpdated).toLocaleString('en-NZ', { 
      year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit', hour12: true,
      timeZone: 'Pacific/Auckland'
    }) : null },
    { label: 'Completed Date', value: job.CompletedDate ? new Date(job.CompletedDate).toLocaleString('en-NZ', { 
      year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit', hour12: true,
      timeZone: 'Pacific/Auckland'
    }) : null },
    { label: 'Synced To Forman', value: job.SyncedToForman },
    { label: 'Last Sync Time', value: job.LastSyncTime ? new Date(job.LastSyncTime).toLocaleString('en-NZ', { 
      year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit', hour12: true,
      timeZone: 'Pacific/Auckland'
    }) : null },
    { label: 'Form Version', value: job.FormVersion },
    { label: 'Source', value: job.Source },
    { label: 'Output To', value: job.OutputTo },
    { label: 'FP Staff Email', value: job.FPStaffEmail },
  ];
  
  const systemSection = buildSection('System', systemFields);
  if (systemSection) sections.push(systemSection);
  
  // Combine all sections
  previewHTML += sections.join('');
  
  // Show preview - use correct element IDs from job-picker-modal.html
  const jobSelectionSection = document.getElementById('jobSelectionSection');
  const jobPreviewSection = document.getElementById('jobPreviewSection');
  const jobPreviewContent = document.getElementById('jobPreviewContent');
  
  if (jobSelectionSection && jobPreviewSection && jobPreviewContent) {
    jobSelectionSection.style.display = 'none';
    jobPreviewSection.style.display = 'block';
    jobPreviewContent.innerHTML = previewHTML;
  } else {
    console.error('Job picker elements not found:', {
      jobSelectionSection: !!jobSelectionSection,
      jobPreviewSection: !!jobPreviewSection,
      jobPreviewContent: !!jobPreviewContent
    });
    alert('Error: Job picker preview elements not found. Please check HTML structure.');
  }
}

// Helper function to build a section
function buildSection(title, fields) {
  const rows = fields
    .filter(field => field.value !== null && field.value !== undefined && field.value !== '')
    .map(field => `
      <div class="preview-row">
        <div class="preview-label">${field.label}</div>
        <div class="preview-value">${field.value}</div>
      </div>
    `);
  
  if (rows.length === 0) return null;
  
  return `
    <div style="margin-top: 24px;">
      <div style="font-size: 1.1em; font-weight: 600; color: #1e3c72; margin-bottom: 12px; border-bottom: 2px solid #e5e7eb; padding-bottom: 4px;">
        ${title}
      </div>
      ${rows.join('')}
    </div>
  `;
}

// Back to job list
function backToJobList() {
  const jobSelectionSection = document.getElementById('jobSelectionSection');
  const jobPreviewSection = document.getElementById('jobPreviewSection');
  
  if (jobSelectionSection && jobPreviewSection) {
    jobPreviewSection.style.display = 'none';
    jobSelectionSection.style.display = 'block';
  }
  
  // Clear selection
  document.querySelectorAll('.job-item').forEach(item => {
    item.classList.remove('selected');
  });
  jobPickerState.selectedJob = null;
  
  const selectBtn = document.getElementById('selectBtn');
  if (selectBtn) {
    selectBtn.disabled = true;
  }
}

// Confirm job selection and pass to parent
function confirmJobSelection() {
  if (!jobPickerState.selectedJob) {
    alert('Please select a job first');
    return;
  }
  
  const rego = jobPickerState.selectedJob.Rego || 'Unknown';
  
  window.selectedJobRego = rego;
  sessionStorage.setItem('selectedJobRego', rego);
  sessionStorage.setItem('selectedJobData', JSON.stringify(jobPickerState.selectedJob));
  
  if (jobPickerState.isInIframe) {
    window.parent.postMessage({
      type: 'JOB_SELECTED',
      job: jobPickerState.selectedJob,
      rego: rego
    }, '*');
  } else {
    if (jobPickerState.onJobSelected) {
      jobPickerState.onJobSelected(jobPickerState.selectedJob);
    }
    alert(`You selected: ${rego}`);
  }
  
  closeJobPicker();
}

// Open job picker
async function openJobPicker(options = {}) {
  const { filterPPI = false, onJobSelected = null } = options;
  
  jobPickerState.selectedJob = null;
  jobPickerState.isPPIMode = filterPPI;
  jobPickerState.showAllJobs = false;
  jobPickerState.onJobSelected = onJobSelected;
  
  document.getElementById('ppiFilter').checked = filterPPI;
  document.getElementById('showAllJobs').checked = false;
  document.getElementById('manualRegoInput').value = '';
  document.getElementById('selectBtn').disabled = true;
  
  // Reset to job selection view
  document.getElementById('jobPreviewSection').style.display = 'none';
  document.getElementById('jobSelectionSection').style.display = 'block';
  
  // Clear filters
  clearAllFilters();
  
  const authOk = await initJobPickerAuth();
  if (!authOk) {
    alert('Authentication failed. Please sign in again.');
    return;
  }
  
  const modal = document.getElementById('jobPickerModal');
  modal.classList.add('active');
  
  await fetchJobsFromSharePoint();
}

// Close job picker
function closeJobPicker() {
  document.getElementById('jobPickerModal').classList.remove('active');
  
  // Reset to job selection view
  document.getElementById('jobPreviewSection').style.display = 'none';
  document.getElementById('jobSelectionSection').style.display = 'block';
  
  jobPickerState.selectedJob = null;
  jobPickerState.onJobSelected = null;
  
  if (jobPickerState.isInIframe) {
    window.parent.postMessage({
      type: 'JOB_PICKER_CLOSED'
    }, '*');
  }
}

// Show error
function showJobPickerError(message) {
  const container = document.getElementById('jobsContainer');
  container.innerHTML = `
    <div class="empty-state">
      <div class="empty-icon">⚠️</div>
      <div>Error Loading Jobs</div>
      <div style="font-size: 0.9em; margin-top: 8px; color: #ef4444;">
        ${message}
      </div>
    </div>
  `;
}

// Message handling
window.addEventListener('message', function(event) {
  if (event.data.type === 'OPEN_PICKER') {
    openJobPicker(event.data.options || {});
  } else if (event.data.type === 'JOBS_DATA_RESPONSE') {
    // Handle jobs data from parent
    handleJobsDataFromParent(event.data.jobs);
  }
});

// Handle jobs data received from parent
function handleJobsDataFromParent(jobs) {
  console.log('Received jobs data from parent:', jobs.length);
  
  // Process jobs similar to fetchJobsFromSharePoint
  const allJobsWithStatus = jobs.filter(job => {
    const rego = job.Rego || job.Registration || job['Registration Number'];
    return rego && String(rego).trim();
  }).map(job => {
    const completionTime = job.CompletionTime;
    const isOpen = !completionTime || String(completionTime).trim() === '';
    const invoiceStr = String(job.InvoiceIdentifier || '').trim();
    
    return {
      ...job,
      parsedDate: parseJobDate(job),
      isOpen: isOpen,
      invoiceId: invoiceStr || 'N/A',
      completionTime: String(completionTime || '').trim() || 'Not completed'
    };
  });
  
  console.log(`Total jobs loaded: ${allJobsWithStatus.length}`);
  console.log(`Open jobs: ${allJobsWithStatus.filter(j => j.isOpen).length}`);
  console.log(`Closed jobs: ${allJobsWithStatus.filter(j => !j.isOpen).length}`);
  
  jobPickerState.allJobs = allJobsWithStatus;
  applyJobFilters();
  jobPickerState.isLoading = false;
  updateJobsDisplay();
}

// Modal click outside
document.addEventListener('click', (event) => {
  if (event.target.id === 'jobPickerModal') {
    closeJobPicker();
  }
});

// Escape key
document.addEventListener('keydown', (event) => {
  if (event.key === 'Escape' && document.getElementById('jobPickerModal').classList.contains('active')) {
    closeJobPicker();
  }
});

// Initialize
document.addEventListener('DOMContentLoaded', function() {
  detectIframe();
  
  if (!jobPickerState.isInIframe) {
    window.openJobPicker = openJobPicker;
    window.closeJobPicker = closeJobPicker;
    window.selectedJobRego = null;
  }
});

</script>

</body>
</html>
