<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Job Picker - Fixed Debug Version</title>
<script src="https://alcdn.msauth.net/browser/2.38.0/js/msal-browser.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #f8fafc; }

/* Modal Styles */
.job-picker-modal { 
  position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 10000; 
  display: flex; align-items: center; justify-content: center; 
  backdrop-filter: blur(4px); opacity: 0; visibility: hidden; 
  transition: all 0.3s ease; 
}
.job-picker-modal.active { opacity: 1; visibility: visible; }

.modal-content { 
  background: #fff; border-radius: 16px; padding: 0; 
  width: 90%; max-width: 800px; max-height: 85vh; 
  box-shadow: 0 20px 25px -5px rgba(0,0,0,0.3); 
  transform: scale(0.9); transition: transform 0.3s ease; 
}
.job-picker-modal.active .modal-content { transform: scale(1); }

.modal-header { 
  background: linear-gradient(135deg, #1e3c72, #2a5298); 
  color: #fff; padding: 20px 24px; border-radius: 16px 16px 0 0; 
  display: flex; justify-content: space-between; align-items: center; 
}
.modal-title { font-size: 1.4em; font-weight: 700; }
.close-btn { 
  background: rgba(255,255,255,0.2); color: #fff; border: none; 
  padding: 8px; border-radius: 6px; cursor: pointer; font-size: 18px; 
  width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; 
}
.close-btn:hover { background: rgba(255,255,255,0.3); }

.modal-body { padding: 24px; max-height: 60vh; overflow-y: auto; }

/* Debug Section */
.debug-section {
  background: #fef2f2; border: 2px solid #fecaca; border-radius: 12px;
  padding: 16px; margin-bottom: 20px;
}
.debug-header { font-weight: 600; color: #dc2626; margin-bottom: 12px; }
.debug-log { 
  background: #1f2937; color: #f9fafb; padding: 12px; border-radius: 8px;
  font-family: 'Courier New', monospace; font-size: 12px; max-height: 150px;
  overflow-y: auto; white-space: pre-wrap;
}

/* Search Section */
.search-section { 
  background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 12px; 
  padding: 20px; margin-bottom: 20px; 
}
.search-header { font-weight: 600; color: #374151; margin-bottom: 12px; }
.search-row { display: grid; grid-template-columns: 1fr auto; gap: 12px; align-items: end; }
.search-input { 
  padding: 12px 16px; border: 2px solid #d1d5db; border-radius: 8px; 
  font-size: 14px; background: #fff; 
}
.search-input:focus { outline: none; border-color: #1e3c72; box-shadow: 0 0 0 3px rgba(30,60,114,0.1); }
.search-btn { 
  background: #1e3c72; color: #fff; border: none; padding: 12px 20px; 
  border-radius: 8px; cursor: pointer; font-weight: 600; 
}
.search-btn:hover { background: #1a3260; }

.filter-toggle { 
  margin-top: 12px; display: flex; align-items: center; gap: 8px; 
}
.checkbox { width: 18px; height: 18px; cursor: pointer; }

/* Jobs List */
.jobs-section { }
.section-header { 
  font-weight: 600; color: #374151; margin-bottom: 16px; 
  display: flex; justify-content: space-between; align-items: center; 
}
.job-count { 
  background: #e2e8f0; color: #64748b; padding: 4px 12px; 
  border-radius: 16px; font-size: 0.85em; 
}

.jobs-list { max-height: 300px; overflow-y: auto; }
.job-item { 
  background: #fff; border: 2px solid #e2e8f0; border-radius: 8px; 
  padding: 16px; margin-bottom: 12px; cursor: pointer; 
  transition: all 0.2s ease; display: flex; justify-content: space-between; align-items: center; 
}
.job-item:hover { border-color: #1e3c72; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
.job-item.selected { border-color: #10b981; background: #ecfdf5; }

.job-info { }
.job-rego { font-weight: 700; font-size: 1.1em; color: #1e3c72; margin-bottom: 4px; }
.job-details { font-size: 0.9em; color: #64748b; }
.job-badge { 
  background: #fef3c7; color: #92400e; padding: 4px 8px; 
  border-radius: 12px; font-size: 0.8em; font-weight: 600; 
}
.job-badge.ppi { background: #dbeafe; color: #1e40af; }

.loading-spinner { 
  display: flex; align-items: center; justify-content: center; 
  padding: 40px; color: #64748b; 
}
.spinner { 
  width: 32px; height: 32px; border: 3px solid #e2e8f0; 
  border-top: 3px solid #1e3c72; border-radius: 50%; 
  animation: spin 1s linear infinite; margin-right: 12px; 
}
@keyframes spin { to { transform: rotate(360deg); } }

.empty-state { 
  text-align: center; padding: 40px; color: #64748b; 
}
.empty-icon { font-size: 48px; margin-bottom: 12px; }

.modal-footer { 
  padding: 20px 24px; background: #f8fafc; border-radius: 0 0 16px 16px; 
  display: flex; justify-content: flex-end; gap: 12px; border-top: 2px solid #e2e8f0; 
}
.btn-cancel { 
  background: #6b7280; color: #fff; border: none; padding: 12px 24px; 
  border-radius: 8px; cursor: pointer; font-weight: 600; 
}
.btn-select { 
  background: #10b981; color: #fff; border: none; padding: 12px 24px; 
  border-radius: 8px; cursor: pointer; font-weight: 600; 
}
.btn-select:disabled { background: #d1d5db; cursor: not-allowed; }

.debug-btn {
  background: #7c3aed; color: #fff; border: none; padding: 8px 16px;
  border-radius: 6px; cursor: pointer; font-weight: 600; margin: 4px;
}

@media (max-width: 768px) {
  .modal-content { width: 95%; margin: 20px; }
  .search-row { grid-template-columns: 1fr; }
  .modal-body { padding: 20px; }
}
</style>
</head>
<body>

<!-- Job Picker Modal -->
<div class="job-picker-modal" id="jobPickerModal">
  <div class="modal-content">
    <div class="modal-header">
      <div class="modal-title">Job Picker - Column Mapping Debug</div>
      <button class="close-btn" onclick="closeJobPicker()">&times;</button>
    </div>
    
    <div class="modal-body">
      <!-- Debug Section -->
      <div class="debug-section">
        <div class="debug-header">Debug Information</div>
        <div class="debug-log" id="debugLog">Ready for debugging...</div>
        <button class="debug-btn" onclick="getColumnMapping()">Get Column Mapping</button>
        <button class="debug-btn" onclick="testWithMapping()">Test With Mapping</button>
        <button class="debug-btn" onclick="showRawData()">Show Raw Data</button>
        <button class="debug-btn" onclick="clearDebugLog()">Clear Log</button>
      </div>
      
      <!-- Direct Search Section -->
      <div class="search-section">
        <div class="search-header">Enter Job Registration Number</div>
        <div class="search-row">
          <input 
            type="text" 
            id="manualRegoInput" 
            class="search-input" 
            placeholder="Type job registration number..."
            onkeypress="handleManualRegoKeypress(event)"
          >
          <button class="search-btn" onclick="selectManualRego()">Select</button>
        </div>
        
        <div class="filter-toggle">
          <input type="checkbox" id="ppiFilter" class="checkbox" onchange="togglePPIFilter()">
          <label for="ppiFilter">Show only PPI (Pre Purchase Inspection) jobs</label>
        </div>
      </div>
      
      <!-- Available Jobs List -->
      <div class="jobs-section">
        <div class="section-header">
          <span>Available Open Jobs</span>
          <span class="job-count" id="jobCount">0 jobs</span>
        </div>
        
        <div id="jobsContainer">
          <div class="loading-spinner">
            <div class="spinner"></div>
            Loading jobs from SharePoint...
          </div>
        </div>
      </div>
    </div>
    
    <div class="modal-footer">
      <button class="btn-cancel" onclick="closeJobPicker()">Cancel</button>
      <button class="btn-select" id="selectBtn" onclick="confirmSelection()" disabled>
        Select Job
      </button>
    </div>
  </div>
</div>

<script>
// Job Picker Configuration
const JOB_PICKER_CONFIG = {
  SPO_HOST: 'roadandrescue.sharepoint.com',
  SPO_SITE_PATH: '/sites/rar',
  SPO_LIST_TITLE: 'Forman Pacific Consolidated Brand Data',
  PPI_JOB_TYPE: 'Pre Purchase Vehicle Inspection'
};

// State
let jobPickerState = {
  msalInstance: null,
  allJobs: [],
  filteredJobs: [],
  selectedJob: null,
  isPPIMode: false,
  onJobSelected: null,
  isLoading: false,
  isInIframe: false,
  rawSharePointData: null,
  columnMapping: null
};

// Debug logging
function debugLog(message) {
  const timestamp = new Date().toLocaleTimeString();
  const logEl = document.getElementById('debugLog');
  if (logEl) {
    logEl.textContent += `[${timestamp}] ${message}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  console.log(`[JobPicker Debug] ${message}`);
}

function clearDebugLog() {
  document.getElementById('debugLog').textContent = '';
}

// MSAL Configuration
const MSAL_CONFIG = {
  auth: {
    clientId: 'd67be044-6aaa-4d01-ada2-da0cc50d2034',
    authority: 'https://login.microsoftonline.com/61ffc6bc-d9ce-458b-8120-d32187c3770d',
    redirectUri: window.location.origin + '/admin'
  },
  cache: { cacheLocation: 'sessionStorage', storeAuthStateInCookie: true }
};

const GRAPH_SCOPES = ['https://graph.microsoft.com/Sites.Read.All'];

// Detect if running in iframe
function detectIframe() {
  jobPickerState.isInIframe = window.self !== window.top;
  debugLog(`Running in iframe: ${jobPickerState.isInIframe}`);
}

// Initialize MSAL
async function initJobPickerAuth() {
  if (jobPickerState.msalInstance) {
    debugLog('MSAL already initialized');
    return true;
  }
  
  try {
    debugLog('Initializing MSAL...');
    
    if (!window.msal || !window.msal.PublicClientApplication) {
      throw new Error('MSAL library not loaded');
    }

    jobPickerState.msalInstance = new msal.PublicClientApplication(MSAL_CONFIG);
    await jobPickerState.msalInstance.initialize();
    debugLog('MSAL initialized successfully');

    const accounts = jobPickerState.msalInstance.getAllAccounts();
    debugLog(`Found ${accounts.length} accounts`);
    
    if (!accounts.length) {
      throw new Error('No authenticated account');
    }

    debugLog(`Active account: ${accounts[0].username}`);
    return true;
  } catch (error) {
    debugLog(`Auth failed: ${error.message}`);
    console.error('Job picker auth failed:', error);
    return false;
  }
}

// Get Graph API token
async function getJobPickerToken() {
  debugLog('Getting Graph API token...');
  
  const account = jobPickerState.msalInstance.getActiveAccount() || 
                 jobPickerState.msalInstance.getAllAccounts()[0];
  if (!account) throw new Error('No signed-in account');

  const request = { scopes: GRAPH_SCOPES, account };
  try {
    const { accessToken } = await jobPickerState.msalInstance.acquireTokenSilent(request);
    debugLog('Token acquired silently');
    return accessToken;
  } catch (err) {
    debugLog(`Silent token failed: ${err.message}, trying interactive...`);
    const resp = await jobPickerState.msalInstance.acquireTokenPopup({ scopes: GRAPH_SCOPES });
    debugLog('Token acquired interactively');
    return resp?.accessToken || '';
  }
}

// Get column mapping
async function getColumnMapping() {
  debugLog('=== Getting Column Mapping ===');
  
  try {
    const token = await getJobPickerToken();
    const siteUrl = `https://graph.microsoft.com/v1.0/sites/${JOB_PICKER_CONFIG.SPO_HOST}:${JOB_PICKER_CONFIG.SPO_SITE_PATH}`;
    const siteResponse = await fetch(siteUrl, { headers: { Authorization: `Bearer ${token}` }});
    const site = await siteResponse.json();
    
    const listNameOData = JOB_PICKER_CONFIG.SPO_LIST_TITLE.replace(/'/g, "''");
    const listsUrl = `https://graph.microsoft.com/v1.0/sites/${site.id}/lists?$filter=displayName eq '${listNameOData}'`;
    const listsResponse = await fetch(listsUrl, { headers: { Authorization: `Bearer ${token}` }});
    const listsData = await listsResponse.json();
    const listId = listsData.value[0].id;
    
    // Get columns
    debugLog('Fetching column definitions...');
    const columnsUrl = `https://graph.microsoft.com/v1.0/sites/${site.id}/lists/${listId}/columns`;
    const columnsResponse = await fetch(columnsUrl, { headers: { Authorization: `Bearer ${token}` }});
    const columnsData = await columnsResponse.json();
    
    // Create mapping
    const columnMapping = {};
    debugLog(`Found ${columnsData.value?.length || 0} columns:`);
    
    columnsData.value?.forEach(col => {
      if (col.name && col.displayName) {
        columnMapping[col.name] = col.displayName;
        debugLog(`  ${col.name} → "${col.displayName}"`);
      }
    });
    
    jobPickerState.columnMapping = columnMapping;
    debugLog(`Column mapping created with ${Object.keys(columnMapping).length} entries`);
    
    // Look for registration-related columns
    const regoColumns = Object.keys(columnMapping).filter(internalName => {
      const displayName = columnMapping[internalName].toLowerCase();
      return displayName.includes('rego') || 
             displayName.includes('registration') || 
             displayName.includes('plate');
    });
    
    if (regoColumns.length > 0) {
      debugLog('=== Found Registration-Related Columns ===');
      regoColumns.forEach(internalName => {
        debugLog(`  ${internalName} → "${columnMapping[internalName]}"`);
      });
    } else {
      debugLog('No obvious registration columns found. All column names:');
      Object.keys(columnMapping).forEach(internalName => {
        debugLog(`  "${columnMapping[internalName]}"`);
      });
    }
    
    return columnMapping;
    
  } catch (error) {
    debugLog(`Column mapping failed: ${error.message}`);
    return null;
  }
}

// Test with column mapping
async function testWithMapping() {
  debugLog('=== Testing With Column Mapping ===');
  
  if (!jobPickerState.columnMapping) {
    debugLog('No column mapping available. Getting it first...');
    await getColumnMapping();
  }
  
  if (!jobPickerState.columnMapping) {
    debugLog('Failed to get column mapping');
    return;
  }
  
  try {
    const token = await getJobPickerToken();
    const siteUrl = `https://graph.microsoft.com/v1.0/sites/${JOB_PICKER_CONFIG.SPO_HOST}:${JOB_PICKER_CONFIG.SPO_SITE_PATH}`;
    const siteResponse = await fetch(siteUrl, { headers: { Authorization: `Bearer ${token}` }});
    const site = await siteResponse.json();
    
    const listNameOData = JOB_PICKER_CONFIG.SPO_LIST_TITLE.replace(/'/g, "''");
    const listsUrl = `https://graph.microsoft.com/v1.0/sites/${site.id}/lists?$filter=displayName eq '${listNameOData}'`;
    const listsResponse = await fetch(listsUrl, { headers: { Authorization: `Bearer ${token}` }});
    const listsData = await listsResponse.json();
    const listId = listsData.value[0].id;
    
    // Get a larger sample to analyze status values
    const itemsUrl = `https://graph.microsoft.com/v1.0/sites/${site.id}/lists/${listId}/items?$expand=fields&$top=50`;
    const itemsResponse = await fetch(itemsUrl, { headers: { Authorization: `Bearer ${token}` }});
    const itemsData = await itemsResponse.json();
    
    debugLog(`Got ${itemsData.value?.length || 0} sample items for analysis`);
    
    if (itemsData.value?.length > 0) {
      // Apply column mapping
      const rawJobs = itemsData.value.map(item => item.fields);
      const mappedJobs = applyColumnMapping(rawJobs);
      
      debugLog('=== Status Field Analysis (First 10 Items) ===');
      
      // Analyze status field values
      const statusValues = {
        CloseAndPost: new Set(),
        Status: new Set(),
        JobStatus: new Set(),
        BookingStatus: new Set(),
        FormanStatus: new Set()
      };
      
      for (let i = 0; i < Math.min(10, mappedJobs.length); i++) {
        const job = mappedJobs[i];
        const rego = job.Rego || 'Unknown';
        
        debugLog(`--- Job ${i + 1}: ${rego} ---`);
        debugLog(`  CloseAndPost: "${job.CloseAndPost || ''}"`);
        debugLog(`  Status: "${job.Status || ''}"`);
        debugLog(`  JobStatus: "${job.JobStatus || ''}"`);
        debugLog(`  BookingStatus: "${job.BookingStatus || ''}"`);
        debugLog(`  FormanStatus: "${job.FormanStatus || ''}"`);
        
        // Collect unique values
        if (job.CloseAndPost) statusValues.CloseAndPost.add(job.CloseAndPost);
        if (job.Status) statusValues.Status.add(job.Status);
        if (job.JobStatus) statusValues.JobStatus.add(job.JobStatus);
        if (job.BookingStatus) statusValues.BookingStatus.add(job.BookingStatus);
        if (job.FormanStatus) statusValues.FormanStatus.add(job.FormanStatus);
      }
      
      debugLog('=== Unique Status Values Found ===');
      Object.keys(statusValues).forEach(fieldName => {
        const values = Array.from(statusValues[fieldName]);
        if (values.length > 0) {
          debugLog(`${fieldName}: ${values.join(', ')}`);
        } else {
          debugLog(`${fieldName}: (no values found)`);
        }
      });
    }
    
  } catch (error) {
    debugLog(`Test with mapping failed: ${error.message}`);
  }
}

// Show raw data
function showRawData() {
  if (jobPickerState.rawSharePointData) {
    debugLog('=== Raw SharePoint Data (First Item) ===');
    const firstItem = jobPickerState.rawSharePointData.value[0];
    if (firstItem) {
      Object.keys(firstItem.fields).forEach(key => {
        const value = firstItem.fields[key];
        if (value && String(value).length < 100) {
          debugLog(`${key}: "${value}"`);
        }
      });
    }
  } else {
    debugLog('No raw data available. Load jobs first.');
  }
}

// Apply column mapping to job data
function applyColumnMapping(rawJobs) {
  if (!jobPickerState.columnMapping) {
    debugLog('No column mapping available - returning raw jobs');
    return rawJobs;
  }
  
  return rawJobs.map(rawJob => {
    const mappedJob = {};
    
    Object.keys(rawJob).forEach(internalName => {
      const displayName = jobPickerState.columnMapping[internalName] || internalName;
      mappedJob[displayName] = rawJob[internalName];
      
      // Also keep original field names for backward compatibility
      mappedJob[internalName] = rawJob[internalName];
    });
    
    return mappedJob;
  });
}

// Fetch jobs from SharePoint with column mapping
async function fetchJobsFromSharePoint() {
  jobPickerState.isLoading = true;
  updateJobsDisplay();
  
  debugLog('=== Starting job fetch with column mapping ===');

  try {
    // Get column mapping first
    if (!jobPickerState.columnMapping) {
      await getColumnMapping();
    }
    
    const token = await getJobPickerToken();
    
    // Get site
    const siteUrl = `https://graph.microsoft.com/v1.0/sites/${JOB_PICKER_CONFIG.SPO_HOST}:${JOB_PICKER_CONFIG.SPO_SITE_PATH}`;
    const siteResponse = await fetch(siteUrl, { headers: { Authorization: `Bearer ${token}` }});
    const site = await siteResponse.json();

    // Get list
    const listNameOData = JOB_PICKER_CONFIG.SPO_LIST_TITLE.replace(/'/g, "''");
    const listsUrl = `https://graph.microsoft.com/v1.0/sites/${site.id}/lists?$filter=displayName eq '${listNameOData}'`;
    const listsResponse = await fetch(listsUrl, { headers: { Authorization: `Bearer ${token}` }});
    const listsData = await listsResponse.json();
    const listId = listsData.value[0].id;

    // Get items
    const itemsUrl = `https://graph.microsoft.com/v1.0/sites/${site.id}/lists/${listId}/items?$expand=fields&$top=999`;
    const itemsResponse = await fetch(itemsUrl, { headers: { Authorization: `Bearer ${token}` }});
    const itemsData = await itemsResponse.json();
    
    jobPickerState.rawSharePointData = itemsData;
    debugLog(`Raw items retrieved: ${itemsData.value?.length || 0}`);

    // Apply column mapping
    const rawJobs = (itemsData.value || []).map(item => item.fields);
    const mappedJobs = applyColumnMapping(rawJobs);
    
    debugLog(`Jobs mapped with column names`);
    
    // Filter for open jobs using multiple possible field names
    const openJobs = mappedJobs.filter(job => {
      // Look for registration in multiple possible fields
      const rego = job.Rego || job.Registration || job['Registration Number'] || 
                   job.Plate || job['Plate Number'] || job.JobRego ||
                   // Check all fields for values that look like registration numbers
                   Object.values(job).find(val => 
                     typeof val === 'string' && /^[A-Z0-9]{3,8}$/i.test(val.trim()));
      
      if (!rego) {
        debugLog(`Skipping job - no registration found`);
        return false;
      }
      
      // More strict status filtering based on actual column names
      const status = String(job.Status || '').toLowerCase();
      const jobStatus = String(job.JobStatus || '').toLowerCase(); 
      const bookingStatus = String(job.BookingStatus || '').toLowerCase();
      const closeAndPost = String(job.CloseAndPost || '').toLowerCase();
      const formanStatus = String(job.FormanStatus || '').toLowerCase();
      
      // Check if job is closed/completed
      const isClosed = closeAndPost === 'yes' || 
                       closeAndPost === 'true' ||
                       closeAndPost === '1' ||
                       status.includes('closed') || 
                       status.includes('completed') || 
                       status.includes('cancelled') ||
                       jobStatus.includes('closed') || 
                       jobStatus.includes('completed') || 
                       jobStatus.includes('cancelled') ||
                       bookingStatus.includes('closed') || 
                       bookingStatus.includes('completed') || 
                       bookingStatus.includes('cancelled') ||
                       formanStatus.includes('closed') || 
                       formanStatus.includes('completed');
      
      if (isClosed) {
        debugLog(`Filtered out job ${rego}: CloseAndPost="${closeAndPost}", Status="${status}", JobStatus="${jobStatus}"`);
        return false;
      }
      
      return true;
    });
    
    debugLog(`Open jobs after filtering: ${openJobs.length}`);
    
    // Show sample of found jobs
    if (openJobs.length > 0) {
      debugLog('=== Sample Open Jobs ===');
      for (let i = 0; i < Math.min(3, openJobs.length); i++) {
        const job = openJobs[i];
        const rego = job.Rego || job.Registration || job['Registration Number'] || 'Unknown';
        debugLog(`${i + 1}. ${rego}`);
      }
    }
    
    jobPickerState.allJobs = openJobs;
    applyJobFilters();
    
  } catch (error) {
    debugLog(`Job fetch error: ${error.message}`);
    console.error('Failed to load jobs:', error);
    showJobPickerError('Failed to load jobs from SharePoint: ' + error.message);
  } finally {
    jobPickerState.isLoading = false;
    updateJobsDisplay();
  }
}

// Apply filters to jobs
function applyJobFilters() {
  let filtered = [...jobPickerState.allJobs];
  debugLog(`Applying filters to ${filtered.length} jobs`);
  
  // PPI filter
  if (jobPickerState.isPPIMode) {
    const beforePPICount = filtered.length;
    filtered = filtered.filter(job => {
      const jobType = String(job.ServiceType || job.JobType || job['Service Type'] || '');
      return jobType.toLowerCase().includes('pre purchase') || 
             jobType.toLowerCase().includes('ppi') ||
             jobType.toLowerCase().includes('inspection');
    });
    debugLog(`PPI filter: ${beforePPICount} -> ${filtered.length} jobs`);
  }
  
  jobPickerState.filteredJobs = filtered;
  debugLog(`Final filtered jobs: ${filtered.length}`);
  updateJobsDisplay();
}

// Toggle PPI filter
function togglePPIFilter() {
  jobPickerState.isPPIMode = document.getElementById('ppiFilter').checked;
  debugLog(`PPI filter toggled: ${jobPickerState.isPPIMode}`);
  applyJobFilters();
}

// Update jobs display
function updateJobsDisplay() {
  const container = document.getElementById('jobsContainer');
  const countEl = document.getElementById('jobCount');
  
  if (jobPickerState.isLoading) {
    container.innerHTML = `
      <div class="loading-spinner">
        <div class="spinner"></div>
        Loading jobs from SharePoint...
      </div>
    `;
    countEl.textContent = 'Loading...';
    return;
  }
  
  const jobs = jobPickerState.filteredJobs;
  countEl.textContent = `${jobs.length} job${jobs.length !== 1 ? 's' : ''}`;
  
  if (!jobs.length) {
    const filterText = jobPickerState.isPPIMode ? 'PPI ' : '';
    container.innerHTML = `
      <div class="empty-state">
        <div class="empty-icon">📋</div>
        <div>No ${filterText}jobs available</div>
        <div style="font-size: 0.9em; margin-top: 8px;">
          ${jobPickerState.isPPIMode ? 'Try unchecking the PPI filter' : 'All jobs may be closed or completed'}
        </div>
      </div>
    `;
    return;
  }
  
  container.innerHTML = `
    <div class="jobs-list">
      ${jobs.map((job, index) => {
        const rego = job.Rego || job.Registration || job['Registration Number'] || 'Unknown';
        const customer = job.CustomerName || job['Customer Name'] || 
                        (job.FirstName && job.LastName ? `${job.FirstName} ${job.LastName}` : '') ||
                        job.Customer || 'Unknown Customer';
        const service = job.ServiceType || job['Service Type'] || job.ServiceRequired || 'Service';
        const isPPI = String(service).toLowerCase().includes('pre purchase') || 
                     String(service).toLowerCase().includes('ppi');
        
        return `
          <div class="job-item" onclick="selectJob(${index})" data-index="${index}">
            <div class="job-info">
              <div class="job-rego">${index + 1}. ${rego}</div>
              <div class="job-details">${customer} - ${service}</div>
            </div>
            ${isPPI ? '<div class="job-badge ppi">PPI</div>' : '<div class="job-badge">Service</div>'}
          </div>
        `;
      }).join('')}
    </div>
  `;
}

// Select job from list
function selectJob(index) {
  debugLog(`Job selected: index ${index}`);
  
  // Clear previous selection
  document.querySelectorAll('.job-item').forEach(item => {
    item.classList.remove('selected');
  });
  
  // Select new job
  const jobItem = document.querySelector(`[data-index="${index}"]`);
  if (jobItem) {
    jobItem.classList.add('selected');
    jobPickerState.selectedJob = jobPickerState.filteredJobs[index];
    document.getElementById('selectBtn').disabled = false;
    
    const rego = jobPickerState.selectedJob.Rego || 
                 jobPickerState.selectedJob.Registration || 
                 jobPickerState.selectedJob['Registration Number'] || 'Unknown';
    debugLog(`Selected job: ${rego}`);
  }
}

// Handle manual rego entry
function handleManualRegoKeypress(event) {
  if (event.key === 'Enter') {
    selectManualRego();
  }
}

function selectManualRego() {
  const input = document.getElementById('manualRegoInput');
  const rego = input.value.trim();
  
  debugLog(`Manual rego entry: "${rego}"`);
  
  if (!rego) {
    alert('Please enter a job registration number');
    return;
  }
  
  // Check if rego exists in filtered list
  const foundInList = jobPickerState.filteredJobs.find(job => {
    const jobRego = job.Rego || job.Registration || job['Registration Number'] || '';
    return String(jobRego).toLowerCase() === rego.toLowerCase();
  });
  
  if (foundInList) {
    debugLog(`Found rego in filtered list`);
    jobPickerState.selectedJob = foundInList;
  } else if (jobPickerState.isPPIMode) {
    debugLog(`Rego not found in PPI mode - rejecting`);
    alert('That registration number is not in the available PPI jobs list.');
    return;
  } else {
    debugLog(`Rego not found - creating manual entry`);
    jobPickerState.selectedJob = { Rego: rego, isManualEntry: true };
  }
  
  confirmSelection();
}

// Confirm job selection
function confirmSelection() {
  if (!jobPickerState.selectedJob) {
    alert('Please select a job first');
    return;
  }
  
  const rego = jobPickerState.selectedJob.Rego || 
               jobPickerState.selectedJob.Registration || 
               jobPickerState.selectedJob['Registration Number'] || 'Unknown';
  debugLog(`Confirming selection: ${rego}`);
  
  // Store selected job in global variable
  window.selectedJobRego = rego;
  
  // Store in session storage for persistence
  sessionStorage.setItem('selectedJobRego', rego);
  sessionStorage.setItem('selectedJobData', JSON.stringify(jobPickerState.selectedJob));
  
  // Handle callback or postMessage based on context
  if (jobPickerState.isInIframe) {
    debugLog('Sending message to parent window');
    window.parent.postMessage({
      type: 'JOB_SELECTED',
      job: jobPickerState.selectedJob,
      rego: rego
    }, '*');
  } else {
    if (jobPickerState.onJobSelected) {
      debugLog('Calling onJobSelected callback');
      jobPickerState.onJobSelected(jobPickerState.selectedJob);
    }
    
    alert(`You selected: ${rego}`);
  }
  
  closeJobPicker();
}

// Open job picker
async function openJobPicker(options = {}) {
  debugLog('=== Opening Job Picker ===');
  debugLog(`Options: ${JSON.stringify(options)}`);
  
  const { filterPPI = false, onJobSelected = null } = options;
  
  jobPickerState.selectedJob = null;
  jobPickerState.isPPIMode = filterPPI;
  jobPickerState.onJobSelected = onJobSelected;
  
  // Set UI state
  document.getElementById('ppiFilter').checked = filterPPI;
  document.getElementById('manualRegoInput').value = '';
  document.getElementById('selectBtn').disabled = true;
  
  // Initialize auth
  const authOk = await initJobPickerAuth();
  if (!authOk) {
    debugLog('Authentication failed - cannot proceed');
    alert('Authentication failed. Please sign in again.');
    return;
  }
  
  // Show modal
  const modal = document.getElementById('jobPickerModal');
  modal.classList.add('active');
  debugLog('Modal shown');
  
  // Load jobs
  await fetchJobsFromSharePoint();
}

// Close job picker
function closeJobPicker() {
  debugLog('Closing job picker');
  document.getElementById('jobPickerModal').classList.remove('active');
  jobPickerState.selectedJob = null;
  jobPickerState.onJobSelected = null;
  
  if (jobPickerState.isInIframe) {
    window.parent.postMessage({
      type: 'JOB_PICKER_CLOSED'
    }, '*');
  }
}

// Show error
function showJobPickerError(message) {
  const container = document.getElementById('jobsContainer');
  container.innerHTML = `
    <div class="empty-state">
      <div class="empty-icon">⚠️</div>
      <div>Error Loading Jobs</div>
      <div style="font-size: 0.9em; margin-top: 8px; color: #ef4444;">
        ${message}
      </div>
    </div>
  `;
}

// Listen for messages from parent window
window.addEventListener('message', function(event) {
  debugLog(`Received message: ${JSON.stringify(event.data)}`);
  
  if (event.data.type === 'OPEN_PICKER') {
    openJobPicker(event.data.options || {});
  }
});

// Close modal when clicking outside
document.addEventListener('click', (event) => {
  if (event.target.id === 'jobPickerModal') {
    closeJobPicker();
  }
});

// Close modal on Escape key
document.addEventListener('keydown', (event) => {
  if (event.key === 'Escape' && document.getElementById('jobPickerModal').classList.contains('active')) {
    closeJobPicker();
  }
});

// Initialize
document.addEventListener('DOMContentLoaded', function() {
  detectIframe();
  debugLog('Job picker initialized');
  
  // Export functions for global use
  if (!jobPickerState.isInIframe) {
    window.openJobPicker = openJobPicker;
    window.closeJobPicker = closeJobPicker;
    window.selectedJobRego = null;
  }
});

</script>

<!-- Test button for standalone mode -->
<div style="position: fixed; top: 20px; right: 20px; z-index: 20000;">
  <button onclick="openJobPicker()" style="background: #1e3c72; color: white; padding: 12px 20px; border: none; border-radius: 8px; cursor: pointer;">
    Open Job Picker
  </button>
</div>

</body>
</html>
